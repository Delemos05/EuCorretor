# -*- coding: utf-8 -*-
"""Untitled20.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kpOHPytHVfBdtj-QY0HmoF6mhC0y9Stq

#**Encontrar o Primeiro Caractere Não Repetido em uma String**

###Descrição: Neste exercício, você deve implementar uma função que encontra o primeiro caractere que não se repete em uma string. Caso todos os caracteres sejam repetidos, a função deve retornar -1.
 Exemplo: firstUniqChar("abacabad")  Saída: 3 ('c') firstUniqChar("aaabb") # Saída: -1 (não há caracteres não repetidos)
"""

def firstUniqChar(palavra):
    i = 0
    while(i<len(palavra)):
      count = 0
      for letra in palavra:
        if(palavra[i] == letra):
          count+=1
      if(count == 1):
        answer = palavra[i]
        i = len(palavra) - 1
      elif(count > 1 and i == len(palavra) - 1):
        answer = '-1'
      i+=1
    return answer

palavra = 'abacabad'
print(firstUniqChar(palavra))
palavra = 'aaabb'
print(firstUniqChar(palavra))

"""#**Mesclar Intervalos**

###Descrição: Dada uma lista de intervalos, você deve implementar uma função que mescla os intervalos sobrepostos. Cada intervalo é representado por um par de números [início, fim]. Caso dois intervalos se sobreponham, eles devem ser combinados em um único intervalo.
Exemplo:
merge_intervals([[1,3], [2,6], [8,10], [15,18]])
Saída: [[1, 6], [8, 10], [15, 18]

merge_intervals([[1,4], [4,5]])
Saída: [[1, 5]]
"""

def merge_intervals(lista):
    i=0
    while(i<len(lista)):
      if(lista[i][i]<lista[i+1][i]):
        inicio = lista[i][i]
        if(lista[i][i+1]<lista[i+1][i+1]):
          fim = lista[i+1][i+1]
          [lista[i][i], lista[i][i+1]]=[inicio, fim]
          lista.remove([lista[i+1][i], lista[i+1][i+1]])
          i = len(lista)-1
      i+=1
    return lista
lista = [[1,3], [2,6], [8,10], [15,18]]
print(merge_intervals(lista))
lista = [[1,4], [4,5]]
print(merge_intervals(lista))

"""#**Word Ladder (Escada de Palavras)**

###Descrição: Neste exercício, você deve implementar uma função que encontra o comprimento do caminho mais curto de transformação de uma palavra inicial para uma palavra final, seguindo as regras abaixo:

A cada transformação, apenas uma letra pode ser alterada.
Cada palavra intermediária deve existir no dicionário fornecido.
A entrada do exercício será composta por duas palavras de mesma dimensão e uma lista de palavras. Sua tarefa é encontrar a sequência mais curta de transformações, ou retornar 0 caso não seja possível.

Exemplo: ladderLength("hit", "cog", ["hot","dot","dog","lot","log","cog"])

Saída: 5 ("hit" -> "hot" -> "dot" -> "dog" -> "cog")
ladderLength("hit", "cog", ["hot","dot","dog","lot","log"])

Saída: 0 (não há caminho possível)
"""

def ladderLength(inicio, fim, lista):
    tem_fim = False
    i = 0
    while i < len(lista):
        if lista[i] == fim:
            tem_fim = True
            break
        i += 1

    if not tem_fim:
        return "0 (não há caminho possível)"
    novaLista = set()

    j = 0
    while j < len(lista):
        novaLista.add(lista[j])
        j += 1

    fila = []
    fila.append((inicio, [inicio]))

    while len(fila) > 0:
        atual, caminho = fila.pop(0)

        pos = 0
        while pos < len(atual):
            letra = 'a'
            while letra <= 'z':
                nova = atual[:pos] + letra + atual[pos+1:]
                if nova == fim:
                    caminho_completo = caminho + [fim]
                    passos = len(caminho_completo)
                    caminhoFinal = " -> ".join(caminho_completo)
                    return f'{passos} ("{caminhoFinal}")'

                if nova in novaLista:
                    fila.append((nova, caminho + [nova]))
                    novaLista.remove(nova)

                letra = chr(ord(letra) + 1)
            pos += 1

    return "0 (não há caminho possível)"


resultado = ladderLength("hit", "cog", ["hot","dot","dog","lot","log","cog"])
print(resultado)
resultado = ladderLength("hit", "cog", ["hot","dot","dog","lot","log"])
print(resultado)